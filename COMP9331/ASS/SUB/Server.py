from fileinput import filename
from Receiver import *
from Listener import *
from Sender import *
from Communicator import *
import HashMessage
from PassManager import PassManager
from ThreadManager import *

class Server():
    def __init__(self, port):
        self.host = UDPCommunicator(src_ip="127.0.0.1", src_port=port, no_timeout=True) # Communicator for handling commands
        self.auth = PassManager()       # For managing accounts
        self.auth.read()                # Load authentication info
        self.threads = ThreadManager()  # Thread manager
        self.commands = ['CRT', 'MSG', 'DLT', 'EDT', 'LST', 'RDT', 'UPD', 'DWN', 'RMV', 'XIT']  # Valid commands
        self.fileReceiver = TCPReceiver(ip="127.0.0.1", port=port)  # Initiate file receiver

    def run(self):
        # Idle information
        print('Waiting for clients')
        seenCommands = {}
        while True:
            # Decode the message received to command and stamp
            # The stamp here is similar to sequence number
            originalCommand, address = self.host.reads()
            command, stamp = HashMessage.decode(originalCommand)
            command = str(command, encoding='utf-8')
            
            # Flag for file transfer
            toReceive = False
            toSend = False
            # To avoid processing a same command several times
            if stamp not in seenCommands:
                # reply is generated by handle
                reply = bytewise(self.handle(command))
                seenCommands[stamp] = reply
                reply = stamp+reply
                if bytewise('uploaded') in reply and 'UPD' in command.split()[1]:
                    toReceive = True
                if bytewise('successful') in reply and 'DWN' in command.split()[1]:
                    toSend = True
            else:
                # If command is processed before, return the stored response
                reply = seenCommands[stamp]

            # Send the reply back
            self.host.send(reply, address[0], address[1])
            # for UPD commands
            if toReceive:
                data = self.fileReceiver.read()
                filename = command.split()[2]+'-'+command.split()[3]
                with open(filename, 'wb') as f:
                    f.write(bytewise(data))
            # for DWN commands
            if toSend:
                filename = command.split()[2]+'-'+command.split()[3]
                with open(str(filename), 'rb') as f:
                    fileContent = f.read()
                    data = self.fileReceiver.read(fileContent)
            # Exit, print idle message if no user is online
            if self.auth.onlineUsers() == 0 and 'XIT' in command.split()[1] and b'None' not in reply:
                print('Waiting for clients')
                
    # Handles all unseen commands
    def handle(self, command):
        command = command.split()
        # For LOGIN command
        if command[1] == 'LOGIN':
            name = command[0]
            # If only two parameters
            if len(command) == 2:
                print('Client authenticating')
                if not self.auth.exist(name):
                    return 'User doesn\'t exist, you are creating a new account\nEnter password: '
                if self.auth.isOnline(name):
                    print(f'{name} has already logged in')
                    return f'{name} has already logged in\n'
                return 'Enter password: '
            
            password = command[2]
            if self.auth.login(name, password):
                print(f'{name} successful login')
                return 'Welcome to the forum\n'

            print('Incorrect password')
            return 'Invalid password\n'
        
        # For valid commands
        elif command[1] in self.commands:
            try:
                response = None
                name = command[0]
                # Ignore for request from offline users
                if not self.auth.isOnline(name):
                    return
                # Parse commands
                if command[1] == 'CRT':
                    response = self.threads.create(name, command[2])
                if command[1] == 'MSG':
                    response = self.threads.post(name, command[2], ' '.join(command[3:]))
                if command[1] == 'DLT':
                    response = self.threads.delete(name, command[2], int(command[3]))
                if command[1] == 'EDT':
                    response = self.threads.edit(name, command[2],int(command[3]), ' '.join(command[4:]))
                if command[1] == 'LST':
                    response = self.threads.listTitles()
                if command[1] == 'RDT':
                    response = self.threads.readTitle(command[2])
                if command[1] == 'UPD': 
                    response = self.threads.upload(name, command[2], command[3])
                if command[1] == 'DWN':
                    response = self.threads.download(command[2], command[3])
                if command[1] == 'RMV':
                    response = self.threads.remove(name, command[2])
                if command[1] == 'XIT':
                    self.auth.logout(name)
                    response = 'Goodbye'

                # Print log
                print(f'{name} issued {command[1]} command')
                noResponseList = ['LST', 'XIT', 'RDT', 'UPD', 'DWN', 'DLT']
                if command[1] not in noResponseList:
                    print(response)
                if command[1] == 'XIT':
                    print(name, 'exited')
                if command[1] == 'RDT':
                    print(f'thread {command[2]} read')
                if command[1] == 'UPD':
                    print(f'{name} uploaded file {command[3]} to {command[2]} thread')
                if command[1] == 'DWN':
                    print(f'{command[3]} downloaded from Thread {command[2]}')
                if command[1] == 'DLT':
                    print('Message has been deleted')
                return response

            except Exception as e:
                # Special logs to match the behaviour in the specs
                if 'cannot' in str(e):
                    if command[1] == 'EDT':
                        print('Message cannot be edited')
                    if command[1] == 'DLT':
                        print('Message cannot be deleted')
                    if command[1] == 'RMV':
                        print(f'Thread {command[2]} cannot be removed')
                return str(e)

import sys
# Run server by python3 Server.py [src_port]
server = Server(int(sys.argv[1]))
server.run()
